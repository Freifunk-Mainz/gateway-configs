timeformat protocol iso long;

# local addresses
define wi_addr_ic		= 10.207.0.56;  # lotuswurzel = wiesbaden1
define wi_addr_wi		= 10.56.0.23; # wi-mesh-ip
define mz_addr_mz		= 10.37.0.23; # mz-mesh-ip
define ffrl_addr_tun_ber	= 100.64.1.21; # internal ffrl-gre-tunnel-ip berlin
define ffrl_addr_tun_dus	= 100.64.1.23; # internal ffrl-gre-tunnel-ip duesseldorf
define ffrl_nat_address		= 185.66.195.36; # public ffrl address for nat

# AS
define mz_as = 65037; # as of mainz
define wi_as = 65036; # as of wiesbaden

# on which addresses bird6 should listen on
listen bgp address wi_addr_ic;
listen bgp address wi_addr_wi;
listen bgp address ffrl_addr_tun_ber;
listen bgp address ffrl_addr_tun_dus;

router id 10.207.0.56;

table icvpn;		# BGP Peerings 4 wi (ICVPN) and local wimz nets
table icvpn_mz;		# BGP Peerings 4 mz (ICVPN) - copy of icvpn
table ffrl;		# BGP Peerings FFRL

# ROA
roa table roa_icvpn {
    include "ebgp_roa_v4.inc";
}

# functions
function is_default() {
    return net ~ [
        0.0.0.0/0
    ];
}

function is_ffrl_nat() {
    return net ~ [
        185.66.195.36/32
    ];
}

function is_ffrl_tunnel_nets() {
    return net ~ [
        100.64.1.20/30+
    ];
}

function is_freifunk() {
    return net ~ [
        10.0.0.0/8{16,24}
    ];
}

function is_dn42() {
    return net ~ [
        172.22.0.0/15{20,28}
    ];
}

function is_chaosvpn() {
    return net ~ [
        172.31.0.0/16+
    ];
}

function is_mwu_self_nets() {
    return net ~ [
        10.56.0.0/16+,
        10.37.0.0/16+
    ];
}

function is_wi_self_net() {
    return net ~ [
        10.56.0.0/16+
    ];
}

function is_mz_self_net() {
    return net ~ [
        10.37.0.0/16+
    ];
}

# filters
filter ebgp_icvpn_import_filter {
    if is_mwu_self_nets() then reject;
    if is_freifunk() then accept;
    if is_dn42() then accept;
    if is_chaosvpn() then accept;
    if roa_check(roa_icvpn) = ROA_VALID then {
        accept;
    } else {
        print "ROA check failed for ", net, " ASN ", bgp_path.last;
    }
    reject;
}

filter ebgp_ffrl_import_filter {
    if is_default() then accept;
    reject;
}

filter ebgp_ffrl_export_filter {
    if is_ffrl_nat() then accept;
    reject;
}

# protocols
# necessary to inform bird about devices
protocol device {
    scan time 30;
};

# learn about directly connected community subnets
protocol direct mwu_subnets {
    table icvpn;
    interface "mzBR";
    interface "wiBR";
    import where is_mwu_self_nets();
};

protocol static ffrl_uplink_hostroute {
    table ffrl;
    route 185.66.195.36/32 reject;
}

protocol direct {
    table ffrl;
    interface "tun-ffrl*";
    import where is_ffrl_tunnel_nets();
}

protocol kernel kernel_mwu {
    scan time 30;
    import none;
    export filter {
        if is_mwu_self_nets() then
            reject;
        krt_prefsrc = wi_addr_ic;
        accept;
    };
    table icvpn;
    kernel table 23;
};

protocol kernel kernel_ffrl {
    scan time 30;
    import none;
    export filter {
        krt_prefsrc = ffrl_nat_address;
        accept;
    };
    table ffrl;
    kernel table 83;
};

# Templates
# templates for iBGP
template bgp bgp_ibgp_wi {
    local wi_addr_wi as wi_as;
    table icvpn;
    import keep filtered on;
    import all;  # EXPERIMENT !!!!!
    export where source = RTS_BGP;
    direct;
    gateway direct;
};

# templates for eBGP
template bgp ebgp_ic {
    local wi_addr_ic as wi_as;
    table icvpn;
    import keep filtered on;
    import filter ebgp_icvpn_import_filter;
    export filter {
        if is_wi_self_net() then {  # own nets
#            bgp_path.prepend(65036);
            accept;
        }
        if is_mz_self_net() then {  # foreign mz nets
            bgp_path.delete(65036);
            bgp_path.prepend(65037);
            bgp_path.prepend(65036);
            accept;
        }
        if source = RTS_BGP then {
            if is_freifunk() || is_dn42() then {
                accept;
            }
        }
        reject;
    };
    direct;
};

template bgp ffrl_uplink {
    table ffrl;
    local as mz_as;
    import keep filtered;
    import filter ebgp_ffrl_import_filter;
    export filter ebgp_ffrl_export_filter;
    next hop self;
    multihop 64;
};


# P E E R I N G S
# iBGP 

protocol bgp wiesbaden2 from bgp_ibgp_wi { # kaschu
    neighbor 10.56.0.208 as wi_as;
};

protocol bgp aubergine from bgp_ibgp_wi { # aubergine
    neighbor 10.56.1.3 as wi_as;
};

# P E E R I N G S
# eBGP (siehe IPv6)

# FFRL Berlin
protocol bgp ffrlber from ffrl_uplink {
    source address 100.64.1.21;
    neighbor 100.64.1.20 as 201701;
    default bgp_local_pref 100;
};

# FFRL Duesseldorf
protocol bgp ffrldus from ffrl_uplink {
    source address 100.64.1.23;
    neighbor 100.64.1.22 as 201701;
    default bgp_local_pref 200;
};

# following the pattern, a load of 'em:
# protocol bgp <PeerName> from ebgp_ic {
#    neighbor <PeerAddrV4> as <PeerAS>;
#};
include "ebgp_peers_v4.inc";
