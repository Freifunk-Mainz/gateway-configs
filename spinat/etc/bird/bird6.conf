timeformat protocol iso long;

# local addresses
define mz_addr_ic     = fec0::a:cf:1:25;        # spinat = mainz2
define wi_addr_wi     = fd56:b4dc:4b1e::a38:7;  # wi-mesh-ip
define mz_addr_mz     = fd37:b4dc:4b1e::a25:7;  # mz-mesh-ip
# prefixes repeated in functions -> see there
define wi_prefix      = fd56:b4dc:4b1e::/48;
define mz_prefix      = fd37:b4dc:4b1e::/48;

# AS
define mz_as = 65037; # as of mainz
define wi_as = 65036; # as of wiesbaden

router id 10.207.1.37;   # traditionally v4-addr as router id

# routing tables
#table icvpn;     # BGP Peerings ICVPN

# ROA
roa table roa_icvpn {
  include "ebgp_roa_v6.inc";
}

# functions
function is_default() {
    return net ~ [
        ::/0
    ];
}

function is_ula() {
    return net ~ [
        fc00::/7{48,64}
    ];
}

function is_mwu_self_nets() {
    return net ~ [
        fd56:b4dc:4b1e::/48+,
        fd37:b4dc:4b1e::/48+
    ];
}

function is_wi_self_net() {
    return net ~ [
        fd56:b4dc:4b1e::/48+
    ];
}

function is_mz_self_net() {
    return net ~ [
        fd37:b4dc:4b1e::/48+
    ];
}

filter ebgp_icvpn_import_filter {
    if is_mwu_self_nets() then reject;
    if roa_check(roa_icvpn) = ROA_VALID then {
        if is_ula() then accept;
    } else {
        if is_ula() then {
            if roa_check(roa_icvpn) = ROA_UNKNOWN then {
                print "ROA UNKNOWN for net, accepting: ", net, " ASN: ", bgp_path.last;
                accept;
            }
            if roa_check(roa_icvpn) = ROA_INVALID then {
                print "ROA INVALID for net, accepting: ", net, " ASN: ", bgp_path.last;
                accept;
            }
        } else {
            print "Non ULA net, rejecting: ", net, " ASN: ", bgp_path.last;
            reject;
        }
        reject;
    }
    reject;
}

# protocols
# necessary to inform bird about devices
protocol device {
    scan time 30;
};

# learn about directly connected community subnets
protocol direct mwu_subnets {
#    table icvpn;
    interface "mzBR";
    interface "wiBR";
    import where is_mwu_self_nets();
};

protocol kernel kernel_mwu {
    scan time 30;
    import none;
    export filter {
        if is_mwu_self_nets() then
            reject;
        krt_prefsrc = mz_addr_ic;
        accept;
    };
#    table icvpn;
    kernel table 23;
};

# template for iBGP
template bgp ibgp_mz {
    local mz_addr_mz as mz_as;
#    table icvpn;
    import all;  # EXPERIMENT !!!!!
    export where source = RTS_BGP;
    direct;
    gateway direct;
};

# template for eBGP
template bgp ebgp_ic {
    local mz_addr_ic as mz_as;
#    table icvpn;
    import filter ebgp_icvpn_import_filter;
    export filter {
        if is_mz_self_net() then {  # own nets
#            bgp_path.prepend(65037);
            accept;
        }
        if is_wi_self_net() then {  # foreign mz nets
            bgp_path.delete(65037);
            bgp_path.prepend(65036);
            bgp_path.prepend(65037);
            accept;
        }
        if source = RTS_BGP then {
            accept;
        }
        reject;
    };
    direct;
};

# P E E R I N G S
# #### iBGP #####

protocol bgp mwu_mainz1 from ibgp_mz { # wasserfloh
    neighbor fd37:b4dc:4b1e::a25:e7 as mz_as;
};

protocol bgp mwu_aubergine from ibgp_mz { # aubergine
    neighbor fd37:b4dc:4b1e::a25:103 as mz_as;
};

protocol bgp mwu_zwiebel from ibgp_mz { # zwiebel
    neighbor fd37:b4dc:4b1e::a25:100 as mz_as;
};

protocol bgp mwu_glueckskeks from ibgp_mz { # glueckskeks
    neighbor fd37:b4dc:4b1e::a25:101 as mz_as;
};

protocol bgp mwu_zuckerwatte from ibgp_mz { # zuckerwatte
    neighbor fd37:b4dc:4b1e::a25:102 as mz_as;
};

protocol bgp mwu_parmesan from ibgp_mz { # parmesan
    neighbor fd37:b4dc:4b1e::a25:2a as mz_as;
};

# P E E R I N G S
# #### eBGP #####

# following the pattern, a load of 'em:
# protocol bgp <PeerName> from ebgp_ic {
#    neighbor <PeerAddrV6> as <PeerAS>;
#};
include "ebgp_peers_v6.inc";



#include ffrl v6 config 
include "ffrl_v6.inc";
